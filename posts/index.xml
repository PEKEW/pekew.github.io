<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on PeiKeWang&#39;s WebSite</title>
    <link>/posts/</link>
    <description>Recent content in Posts on PeiKeWang&#39;s WebSite</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2022&lt;/a&gt;
</copyright>
    <lastBuildDate>Mon, 17 Oct 2022 23:20:43 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>西瓜书 学习笔记 前置知识</title>
      <link>/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 17 Oct 2022 23:20:43 +0800</pubDate>
      
      <guid>/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</guid>
      <description>确切来说，我是第一次“认真地”“从头到尾地”学习这本西瓜书。功利一些，这是数学所入学考试的参考书之一，但奈何没有重点谈起，所以只好从头到尾认真地学习。</description>
    </item>
    
    <item>
      <title>把所有typing Work优雅地迁移至vim VIM完全配置</title>
      <link>/posts/%E6%8A%8A%E6%89%80%E6%9C%89typing-work%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%81%E7%A7%BB%E8%87%B3vim-vim%E5%AE%8C%E5%85%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 12 Oct 2022 17:59:08 +0800</pubDate>
      
      <guid>/posts/%E6%8A%8A%E6%89%80%E6%9C%89typing-work%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%81%E7%A7%BB%E8%87%B3vim-vim%E5%AE%8C%E5%85%A8%E9%85%8D%E7%BD%AE/</guid>
      <description>文末贴上了完整的配置文件 以下前置工作，必要选项为红色字体，可选项为蓝色字体 如果使用Mac OS, 推荐直接使用MacVIM， 否则使用NeoVIM。整体上配置方</description>
    </item>
    
    <item>
      <title>Sequential,MoudleList,和ModuleDict 3</title>
      <link>/posts/sequentialmoudlelist%E5%92%8Cmoduledict-3/</link>
      <pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/sequentialmoudlelist%E5%92%8Cmoduledict-3/</guid>
      <description>Sequential,MoudleList,和ModuleDict 3 ModuleDict 构造方法 ModuleDict的构造方法和ModuleList一样直接，逻辑也类似</description>
    </item>
    
    <item>
      <title>Sequential,MoudleList,和ModuleDict 2</title>
      <link>/posts/sequentialmoudlelist%E5%92%8Cmoduledict-2/</link>
      <pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/sequentialmoudlelist%E5%92%8Cmoduledict-2/</guid>
      <description>MoudleList 和命名一样，ModuleList是有着Python List行为的Module类。他和Sequential最主要的区别在于需要自己实现forward方</description>
    </item>
    
    <item>
      <title>Sequential,MoudleList,和ModuleDict 1</title>
      <link>/posts/sequentialmoudlelist%E5%92%8Cmoduledict-1/</link>
      <pubDate>Wed, 24 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/sequentialmoudlelist%E5%92%8Cmoduledict-1/</guid>
      <description>Sequential 简而言之：nn.Sequential是Moudle的子类，它的构造方法接受一系列子模型作为输入。同时也定义了forward()方法，这是nn.Seq</description>
    </item>
    
    <item>
      <title>在Pytorch中慎用list</title>
      <link>/posts/%E5%9C%A8pytroch%E4%B8%AD%E6%85%8E%E7%94%A8list/</link>
      <pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/%E5%9C%A8pytroch%E4%B8%AD%E6%85%8E%E7%94%A8list/</guid>
      <description>&lt;h2 id=&#34;问题背景&#34;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;在自定义的模型参数需要被优化的时候，需要给优化器传入一个可迭代对象，一般情况下，可以通过把自定义的参数注册为&lt;code&gt;torch.nn.Parameter&lt;/code&gt;类，直接和模型本身的参数一起通过&lt;code&gt;model.parameters()&lt;/code&gt;返回。但如果需要把自定义参数和模型参数单独优化时，就需要单独返回一个可迭代的参数对象，且不能为&lt;code&gt;torch.nn.Parameter&lt;/code&gt;类，因为&lt;code&gt;torch.nn.Parameter&lt;/code&gt;会把自定义参数当做模型参数一起注册到模型的参数字典中，常用的做法是将自定义的参数定义为&lt;code&gt;Variable&lt;/code&gt;类，并在模型实现时单独实现返回自定义参数迭代对象的方法，常用的返回一个迭代对象的方法有:&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
